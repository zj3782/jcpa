<?xml version="1.0"?> <ruleset name="jcpa pmd rules" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd" xsi:noNamespaceSchemaLocation="http://pmd.sourceforge.net/ruleset_2_0_0.xsd"><description>jcpa pmd rules -- generate by admin at the time of 2012.12.17 09:09:35</description><rule name="ProbeSizeOfArrayOrCollectionBeforeForStatement" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=1" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement
[
descendant::*/IfStatement/descendant::*[RelationalExpression]/descendant::*/Literal[@Image="0"]
]
[
ends-with(descendant::*/IfStatement/descendant::*/Name/@Image,'.length')
]
[starts-with(
descendant::*/IfStatement/descendant::*/Name/@Image,
concat(descendant::*/IfStatement/descendant::*/ForStatement/descendant::*/Name/@Image, ".")
)]
|
//BlockStatement
[
ends-with(
descendant::*/IfStatement/Expression//RelationalExpression[@Image=">"][PrimaryExpression/PrimaryPrefix/Literal[@Image="0"]]
/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount="0"]]/Name/@Image,'.size'
)]
[starts-with(
descendant::*/IfStatement/Expression//RelationalExpression[@Image=">"][PrimaryExpression/PrimaryPrefix/Literal[@Image="0"]]
/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount="0"]]/Name/@Image,
concat(
descendant::*/IfStatement/descendant::*/ForStatement/descendant::*/Name/@Image, ".")
)]]]></value></property></properties><description>It is unnecessary to evaluate the size.</description><priority>3</priority><example><![CDATA[public void negativeMethod() {
        String[] parts = "en_US".split("_");
        List<String> partsList = null;
        if (parts.length > 0) {
            partsList = Arrays.asList(parts);
        }
        assert (partsList != null);
}
-->
public void postiveMethod() {
        String[] parts = "en_US".split("_");
        List<String> partsList = null;
        partsList = Arrays.asList(parts);
        assert (partsList != null);
}]]></example></rule><rule name="UnnecessaryLogicalJudgement" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=2" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement
[
Statement/IfStatement/descendant::*[EqualityExpression]/descendant::*/Literal/NullLiteral
]
[
descendant::*/IfStatement/descendant::*[EqualityExpression]/descendant::*/PrimaryPrefix/Name/@Image=
preceding-sibling::*[descendant::*/AllocationExpression]/descendant::*/VariableDeclaratorId/@Image 
]
[
not(preceding-sibling::*[descendant::*/AssignmentOperator]) or
not(descendant::*/IfStatement/descendant::*[EqualityExpression]/descendant::*/Name/@Image=
preceding-sibling::*[descendant::*/AssignmentOperator]/descendant::*/PrimaryPrefix/Name/@Image)
]
|
//BlockStatement
[
Statement/IfStatement/descendant::*/EqualityExpression[@Image="=="]
[descendant::*/Literal/NullLiteral]/PrimaryExpression/PrimaryPrefix/Name/@Image=
preceding-sibling::*/LocalVariableDeclaration/VariableDeclarator[descendant::*/Literal/NullLiteral]/VariableDeclaratorId/@Image
]
[
not(preceding-sibling::*[descendant::*/AssignmentOperator]) or
not(descendant::*/IfStatement/descendant::*[EqualityExpression]/descendant::*/Name/@Image=
preceding-sibling::*[descendant::*/AssignmentOperator]/descendant::*/PrimaryPrefix/Name/@Image)
]
|
//BlockStatement
[
Statement/IfStatement/Expression/EqualityExpression[@Image="!="][PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]/PrimaryExpression/PrimaryPrefix/Name/@Image=
preceding-sibling::*/LocalVariableDeclaration/VariableDeclarator
[VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal]
[not(descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments]/Name)]
[not(descendant::*/Literal/NullLiteral)]
/VariableDeclaratorId/@Image]
[
not(preceding-sibling::*[descendant::*/AssignmentOperator]) or
not(descendant::*/IfStatement/descendant::*[EqualityExpression]/descendant::*/Name/@Image=
preceding-sibling::*[descendant::*/AssignmentOperator]/descendant::*/PrimaryPrefix/Name/@Image)
]]]></value></property></properties><description>It is unnecessary to evaluate logical expression.</description><priority>3</priority><example><![CDATA[public String negativeMethod() {
        String signal = null;
        Scanner in = new Scanner(System.in);
        String what = in.nextLine();
        if (signal == null) {
            if (what == "Yes" || what == "No") {
                signal = what;
            }
        }
        return signal;
}
-->
public String postiveMethod() {
        String signal = "Yes";
        Scanner in = new Scanner(System.in);
        String what = in.nextLine();
        if (what == "Yes" || what == "No") {
                signal = what;
        }
        return signal;
}]]></example></rule><rule name="ReclaimMemorySpace" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=3" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement
[Statement/StatementExpression/AssignmentOperator/following-sibling::*[self::Expression and position()=1]/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
[not(ancestor::*/following-sibling::*/descendant::*/PrimaryPrefix/Name/@Image=descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/PrimaryPrefix/Name/@Image=descendant::*/PrimaryPrefix/Name/@Image)]
[not(ancestor::ClassOrInterfaceBodyDeclaration/ConstructorDeclaration/FormatParameters/@ParameterCount="0")]]]></value></property></properties><description>Local variable is explicitly reclaimed.</description><priority>3</priority><example><![CDATA[public void negativeMethod() {
        String question = "?";
        process(question);
        question = null;
} -->
public String postiveMethod() {
        String question = "?";
        process(question);
}]]></example></rule><rule name="CallExpensiveFunctionTwiceOrMore" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=4" class="com.jcpa.pattern.javaclass.CallExpensiveFunctionJavaRule"><properties><property name="aux"><value><![CDATA[factorial,MethodFactory.getInstance,.trim,.find]]></value></property></properties><description>Function result is not preserved.</description><priority>2</priority><example><![CDATA[public long negativeMethod() {
        long part1 = costMethod(6);
        long part2 = costMethod(6);
        return part1 + part2;
}
-->
public long positiveMethod() {
        long part = factorial(6);
        return 2part;
}]]></example></rule><rule name="SuboptimalLogicalExpression" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=5" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//Expression
[
    ConditionalAndExpression
    [
        count(descendant::UnaryExpressionNotPlusMinus[@Image="!"])>1
    ]
    or AndExpression
    [
        count(descendant::UnaryExpressionNotPlusMinus[@Image="!"])>1
    ]
        or ConditionalOrExpression
    [
        count(descendant::UnaryExpressionNotPlusMinus[@Image="!"])>1
    ]
    or InclusiveOrExpression
    [
        count(descendant::UnaryExpressionNotPlusMinus[@Image="!"])>1
    ]
]]]></value></property></properties><description>! Operators are not reduced.</description><priority>3</priority><example><![CDATA[public boolean negativeMethod(boolean l, boolean r, boolean m) {
        return (!l & !r & !m);
}
-->
public boolean positiveMethod(boolean l, boolean r, boolean m) {
     return (!(l | r | m));
}]]></example></rule><rule name="OperateUnsynchronizedCollection" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=6" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//ClassOrInterfaceBodyDeclaration
[
FieldDeclaration[descendant::*/ClassOrInterfaceType[@Image="Map"]]
/VariableDeclarator[descendant::*/AllocationExpression/ClassOrInterfaceType[@Image="HashMap"]]/VariableDeclaratorId
]
[
following-sibling::*
[self::ClassOrInterfaceBodyDeclaration]
[descendant::*/PrimaryExpression/PrimarySuffix[@Image="putAll"]]
/descendant::*/PrimaryExpression[PrimarySuffix[@Image="putAll"]]/PrimarySuffix/@Image
=
FieldDeclaration[descendant::*/ClassOrInterfaceType[@Image="Map"]]
/VariableDeclarator[descendant::*/AllocationExpression/ClassOrInterfaceType[@Image="HashMap"]]/VariableDeclaratorId/@Image
]
|
//ClassOrInterfaceBodyDeclaration
[
FieldDeclaration[descendant::*/ClassOrInterfaceType[@Image="Map"]]
/VariableDeclarator[descendant::*/AllocationExpression/ClassOrInterfaceType[@Image="HashMap"]]/VariableDeclaratorId
]
[starts-with(
following-sibling::*[self::ClassOrInterfaceBodyDeclaration]
[descendant::*/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,".putAll")]]
/descendant::*/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,".putAll")]/@Image
,
FieldDeclaration[descendant::*/ClassOrInterfaceType[@Image="Map"]]
/VariableDeclarator[descendant::*/AllocationExpression/ClassOrInterfaceType[@Image="HashMap"]]/VariableDeclaratorId/@Image
)]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Set"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimarySuffix/Arguments[@ArgumentCount=1]/
descendant::*/ClassOrInterfaceType[@Image="ConcurrentHashMap"]/TypeArguments
]/PrimaryExpression/PrimaryPrefix/Name/@Image)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Set"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType]
/PrimaryExpression/PrimaryPrefix/Name/@Image
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".add")
]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="List"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=1]]
/Name[@Image="Collections.synchronizedList"]]
/PrimaryExpression/PrimaryPrefix/Name/@Image)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="List"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType]
/PrimaryExpression/PrimaryPrefix/Name/@Image
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".add")
]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Map"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=1]]
/Name[@Image="Collections.synchronizedMap"]]
/PrimaryExpression/PrimaryPrefix/Name/@Image)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Map"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableDeclaratorId/@Image
=following-sibling::*[ConstructorDeclaration]/descendant::*/StatementExpression
[Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType]
/PrimaryExpression/PrimaryPrefix/Name/@Image
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".put")
]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Set"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableInitializer/
Expression/PrimaryExpression/PrimarySuffix/Arguments[@ArgumentCount=1]/
descendant::*/ClassOrInterfaceType[@Image="ConcurrentHashMap"]/TypeArguments)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Set"]/descendant::*/TypeArgument]
/VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".add")
]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="List"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableInitializer/
Expression/PrimaryExpression/PrimarySuffix[preceding-sibling::*[position()=1 and self::PrimaryPrefix]/Name[@Image="Collections.synchronizedList"]]/Arguments)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="List"]/descendant::*/TypeArgument]
/VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".add")
]
|
//ClassOrInterfaceBodyDeclaration
[not(
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Map"]
/descendant::*/TypeArgument]/VariableDeclarator/VariableInitializer/
Expression/PrimaryExpression/PrimarySuffix[preceding-sibling::*[position()=1 and self::PrimaryPrefix]/Name[@Image="Collections.synchronizedMap"]]/Arguments)
]
[
FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Map"]/descendant::*/TypeArgument]
/VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression
]
[
following-sibling::*[MethodDeclaration]
[count(descendant::*[@Synchronized="true"])=0]
[count(descendant::*/SynchronizedStatement)=0]
/descendant::*/Name/@Image=concat(FieldDeclaration/VariableDeclarator/VariableDeclaratorId/@Image, ".put")
]]]></value></property></properties><description>Object is not synchronized.</description><priority>1</priority><example><![CDATA[Set<String> labels = new HashSet<String>();
public void negativeMethod() {
        safeSet.add("A");
}
-->
public void positiveMethod() {
        synchronized (unsafeSet) {
            safeSet.add("A");
        }
}]]></example></rule><rule name="LegacyUsageForLoop" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=7" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement
[
descendant::*/ForStatement/Expression
/RelationalExpression/PrimaryExpression[2]/PrimaryPrefix/Name/@Image=
preceding-sibling::*/LocalVariableDeclaration/VariableDeclarator
[ends-with(VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,".length")]
[starts-with(VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,concat(
ancestor::BlockStatement/preceding-sibling::*/LocalVariableDeclaration[Type/ReferenceType/@Array="true"]/VariableDeclarator/VariableDeclaratorId/@Image,"."))]
[starts-with(VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,concat(
ancestor::BlockStatement/following-sibling::*/descendant::*/ForStatement/Statement/descendant::*/BlockStatement
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/PrimaryExpression[not(ancestor::*/PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/PrimaryExpression[not(ancestor::*/PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::Statement/preceding-sibling::*[position()=1 and self::ForUpdate]/descendant::*/PrimaryPrefix/Name/@Image]
/Name/@Image,"."))]
/VariableDeclaratorId/@Image
]
|
//BlockStatement
[
starts-with(descendant::*/ForStatement/Expression/RelationalExpression/PrimaryExpression[2]/PrimaryPrefix/Name/@Image,concat(
preceding-sibling::*/LocalVariableDeclaration[Type/ReferenceType/@Array="true"]/VariableDeclarator/VariableDeclaratorId/@Image,"."))
]
[
ends-with(descendant::*/ForStatement/Expression/RelationalExpression/PrimaryExpression[2]/PrimaryPrefix/Name/@Image,".length")
]
[
descendant::*/ForStatement[starts-with(Expression/RelationalExpression/PrimaryExpression[2]/PrimaryPrefix/Name/@Image,
concat(Statement/descendant::*/BlockStatement
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/PrimaryExpression[not(ancestor::*/PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/PrimaryExpression[not(ancestor::*/PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/ArgumentList/Expression/descendant::*/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::*/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::*/descendant::*/Expression/descendant::*/PrimaryExpression
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(preceding-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
[not(following-sibling::PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Name/@Image=ancestor::*/ForUpdate/descendant::*/PrimaryPrefix/Name/@Image)]
/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::Statement/preceding-sibling::*[position()=1 and self::ForUpdate]/descendant::*/PrimaryPrefix/Name/@Image]
/Name/@Image,"."))]
]
|
//BlockStatement
[ends-with(
Statement/WhileStatement/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=0]]/Name/@Image,".hasNext"
)]
[starts-with(
Statement/WhileStatement/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=0]]/Name/@Image,
preceding-sibling/LocalVariableDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Iterator"]]/VariableDeclarator/VariableDeclaratorId/@Image
)]
[ends-with(
Statement/WhileStatement/Statement/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=0]]/Name/@Image,".next"
)]
[ends-with(preceding-sibling::BlockStatement
/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount=0]]/Name/@Image,".iterator")]]]></value></property></properties><description>Old version's usage is not recommended.</description><priority>4</priority><example><![CDATA[public void negativeMethod() {
        String[] strs = { "E", "F", "G", "H" };
        for (int i = 0; i < strs.length; i++) {
            assert (strs[i] != null);
        }
        List<String> strList = Arrays.asList(strs);
        Iterator<String> it = strList.iterator();
        while (it.hasNext()) {
            assert (it.next() != null);
        }

        Set<String> strSet = new HashSet<String>(strList);
        Iterator<String> itr = strSet.iterator();
        while (itr.hasNext()) {
            assert (itr.next() != null);
        }
}
-->
public void positiveMethod() {
        String[] strs = { "A", "B", "C", "D" };
        for (String str : strs) {
            assert (str != null);
        }
        List<String> strList = Arrays.asList(strs);
        for (String str : strList) {
            assert (str != null);
        }

        Set<String> strSet = new HashSet<String>(strList);
        for (String str : strSet) {
            assert (str != null);
        }
}]]></example></rule><rule name="UnspecifyTargetTypeInArrayConversion" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=8" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//CastExpression[Type/ReferenceType/ClassOrInterfaceType[@Image != "Object"]]//PrimaryExpression
[
PrimaryPrefix/Name[ends-with(@Image, '.toArray')]
and
PrimarySuffix/Arguments[count(*) = 0]
and
count(PrimarySuffix) = 1
]]]></value></property></properties><description>Target type is not specified.</description><priority>2</priority><example><![CDATA[public String[] negativeMethod() {

        return (String[]) strList.toArray();
}
-->
public String[] postiveMethod () {

        return strList.toArray(new String[0]);
}]]></example></rule><rule name="ExpensiveOperationsInSynchronizedBlock" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=9" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//ClassOrInterfaceBodyDeclaration
[
descendant::*/BlockStatement/Statement/SynchronizedStatement
[
descendant::*/BlockStatement/descendant::*/PrimaryExpression/PrimarySuffix[preceding-sibling::*[position()=1 and self::PrimaryPrefix]/Name[contains(@Image,"costMethod") or contains(@Image,"excludecostMethod") or contains(@Image,"includecostMethod") or contains(@Image,"processItem")]]/Arguments[@ArgumentCount>=0]
]
/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
preceding-sibling::*/FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType[@Image="Map" or @Image="Set" or @Image="List"]/TypeArguments]/VariableDeclarator/VariableDeclaratorId/@Image
]
/descendant::*/BlockStatement/Statement/SynchronizedStatement/descendant::*/BlockStatement/descendant::*/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount>=0]]/Name[contains(@Image,"costMethod") or contains(@Image,"excludecostMethod") or contains(@Image,"includecostMethod") or contains(@Image,"processItem")]]]></value></property></properties><description>Expensive operation(s) is in synchronized block.</description><priority>1</priority><example><![CDATA[public void negativeMethod() {
        synchronized (strList) {
            strList.add("F");
            costMethod();
        }
}
-->
public void positiveMethod() {
        synchronized (strList) {
            strList.add("E");
        }
        costMethod();
}]]></example></rule><rule name="SynchronizeCollectionWithLockVariable" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=10" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//ClassOrInterfaceBodyDeclaration
[
starts-with(MethodDeclaration/descendant::*/BlockStatement
[ends-with(preceding-sibling::*/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments]/Name/@Image,'.lock')]
/descendant::*/BlockStatement/descendant::*/PrimaryExpression/PrimaryPrefix[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments]/Name/@Image,
concat(preceding-sibling::*/FieldDeclaration[descendant::*/ClassOrInterfaceType[@Image="Map" or @Image="Set" or @Image="List"]]/descendant::*/VariableDeclaratorId/@Image,'.'))
]
/MethodDeclaration/MethodDeclarator]]></value></property></properties><description>Lock cost is higher than object operation.</description><priority>1</priority><example><![CDATA[public class  negativeClass{
    private final Map<String, Data> m = new HashMap<String, Data>();
    private final ReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();
    public Data get(String key) {
        r.lock();
        try {
            return m.get(key);
        } finally {
            r.unlock();
        }
    }
    public Data put(String key, Data value) {
        w.lock();
        try {
            return m.put(key, value);
        } finally {
            w.unlock();
        }
    }
}

-->
public class  positiveClass {
    private final Map<String, Data> m = Collections.synchronizedMap(new HashMap<String, Data>());
    private final ReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();
    public Data get(String key) {
          return m.get(key);
    }
    public Data put(String key, Data value) {
          return m.put(key, value);
    }
}]]></example></rule><rule name="UseSynchronizedSet" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=11" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement/descendant::*/PrimaryExpression/PrimaryPrefix
[starts-with(Name/@Image,'Collections.')]
[ends-with(Name/@Image,'.synchronizedSet')]
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount="1"]/ArgumentList/descendant::*/
AllocationExpression[ClassOrInterfaceType[@Image="HashSet"]]/Arguments[@ArgumentCount="0"]]]]></value></property></properties><description>Exclusive set is not recommended.</description><priority>1</priority><example><![CDATA[public Set<String> negativeMethod () {
     return Collections.synchronizedSet(new HashSet<String>());
}
-->
public Set<String> postiveMethod () {
     return Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
}]]></example></rule><rule name="CallCombinativeFunctionTwiceOrMoreInLoop" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=12" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[
//ForStatement/Statement/descendant::*/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount>"0"]]
/Name[contains(@Image,"cominativeMethod") or contains(@Image,"serviceA.call") or contains(@Image,"processRow") or contains(@Image,"Configuration.getInstance") or contains(@Image,"ServiceSessionManager.getInstance") or contains(@Image,"ServiceManagerFactory.getServiceManager") or contains(@Image,"SPIContextManager.getSPIContext")]
|
//WhileStatement/Statement/descendant::*/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount>"0"]]
/Name[contains(@Image,"cominativeMethod") or contains(@Image,"serviceA.call") or contains(@Image,"processRow") or contains(@Image,"Configuration.getInstance") or contains(@Image,"ServiceSessionManager.getInstance") or contains(@Image,"ServiceManagerFactory.getServiceManager") or contains(@Image,"SPIContextManager.getSPIContext")]
|
//DoStatement/Statement/descendant::*/PrimaryExpression/PrimaryPrefix
[following-sibling::*[position()=1 and self::PrimarySuffix]/Arguments[@ArgumentCount>"0"]]
/Name[contains(@Image,"cominativeMethod") or contains(@Image,"serviceA.call") or contains(@Image,"processRow") or contains(@Image,"Configuration.getInstance") or contains(@Image,"ServiceSessionManager.getInstance") or contains(@Image,"ServiceManagerFactory.getServiceManager") or contains(@Image,"SPIContextManager.getSPIContext")]]]></value></property></properties><description>Combinative functions in loop are not combined.</description><priority>1</priority><example><![CDATA[public void negativeMethod() {
     String[] keys = { "A", "B", "C", "D" };
     for (String key: keys) {
            Row row = DBManager.getRowByID(key);
            processRow(row);
     }
}
-->
public void postiveMethod() {
     String[] keys = { "A", "B", "C", "D" };
     List<Row> rows = dbManager.getRowByID(keys);
     for (Row row: rows) {
            processRow(row);
     }
}]]></example></rule><rule name="ComputationalComplexityProblem" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=13" class="net.sourceforge.pmd.lang.rule.XPathRule"><properties><property name="xpath"><value><![CDATA[//BlockStatement
[count(
Statement[ForStatement or WhileStatement or DoStatement]
/descendant::*/Statement[ForStatement or WhileStatement or DoStatement]
)>0]]]></value></property></properties><description>Computation Complexity is O(square of N) or higher.</description><priority>2</priority><example><![CDATA[for (int i : nums)
    for (int j : nums) {
        sum += i * j;
    }
}]]></example></rule><rule name="CallCombinativeFunctionTwiceOrMore" language="java" since="5.0" scope="inner-class" message="" externalInfoUrl="pattern.jsp?id=14" class="com.jcpa.pattern.javaclass.CombinativeFunctionJavaRule"><properties><property name="aux"><value><![CDATA[cominativeMethod,cominativeMethod2,serviceA.call,processRow,Configuration.getInstance,ServiceSessionManager.getInstance,ServiceManagerFactory.getServiceManager,SPIContextManager.getSPIContext]]></value></property></properties><description>Combinative functions are not combined.</description><priority>1</priority><example><![CDATA[public void negativeMethod () {
        cominativeMethod("A");
        cominativeMethod("B");
}
-->
public void postiveMethod() {
        cominativeMethod(new String[] { "A", "B" });
}]]></example></rule></ruleset>